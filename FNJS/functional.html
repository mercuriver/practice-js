<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>함수형으로 전환하기</title>
    <script src="js/_.js"></script>
  </head>
  <body>
    <script>
      var users = [
        { id: 1, name: 'ID', age: 36 },
        { id: 2, name: 'BJ', age: 32 },
        { id: 3, name: 'JM', age: 32 },
        { id: 4, name: 'PJ', age: 27 },
        { id: 5, name: 'HA', age: 25 },
        { id: 6, name: 'JE', age: 26 },
        { id: 7, name: 'JI', age: 31 },
        { id: 8, name: 'MP', age: 23 },
      ];

      // 1. 명령형 코드
      // 1.1. 30세 이상인 users를 거른다.

      // var temp_users = [];
      // for (var i = 0; i < users.length; i++) {
      //   if (users[i].age >= 30) {
      //     temp_users.push(users[i]);
      //   }
      // }
      // console.log(temp_users);

      // 1.2. 30세 이상인 users의 names를 수집한다.
      // var names = [];
      // for (var i = 0; i < temp_users.length; i++) {
      //   names.push(temp_users[i].name);
      // }
      // console.log(names);

      // 1.3. 30세 미만인 users를 거른다.
      // var temp_users = [];
      // for (var i = 0; i < users.length; i++) {
      //   if (users[i].age < 30) {
      //     temp_users.push(users[i]);
      //   }
      // }
      // console.log(temp_users);

      // 1.4. 30세 미만인 users의 ages를 수집한다.
      // var ages = [];
      // for (var i = 0; i < temp_users.length; i++) {
      //   ages.push(temp_users[i].age);
      // }
      // console.log(ages);

      // 2. 함수형 코드
      // 2.1. _filter, _map으로 리팩토링
      // _.js로 이동
      // function _filter(list, predi) {
      //   var new_list = [];
      //   _each(list, function (val) {
      //     if (predi(val)) new_list.push(val);
      //   });
      //   return new_list;
      // }

      // function _map(list, mapper) {
      //   var new_list = [];
      //   _each(list, function (val) {
      //     new_list.push(mapper(val));
      //   });
      //   return new_list;
      // }

      /*
        > 함수형 프로그래밍은 값을 선언 후 진행하는 것이 아닌,
        함수를 통해 한번에 값을 만들어내는 것이 바람직하다.
        때문에 변수 할당은 최소화하는 것이 좋음
      */

      console.log(
        _map(
          _filter(users, function (user) {
            return user.age >= 30;
          }),
          function (user) {
            return user.name;
          }
        )
      );

      console.log(
        _map(
          _filter(users, function (user) {
            return user.age < 30;
          }),
          function (user) {
            return user.age;
          }
        )
      );

      // 2.2. each 만들기
      // 2.2.1. _each로 _map, _filter 중복 제거
      // _.js로 이동
      // function _each(list, iter) {
      //   for (var i = 0; i < list.length; i++) {
      //     iter(list[i]);
      //   }
      //   return list;
      // }

      // 2.2.2. 외부 다형성
      // 2.2.2.1. array_like, arguments, document.querySelectorAll
      /*
        > map, filter같은 기능은 array method로 기본적으로 제공되는 기능이다. 함수가 아니라 메소드다

        가령 다음과 같은 코드는 querySelectorAll() 반환값이 array_like 객체이므로 array method가 지원되지 않아 에러가 발생한다.

        document.querySelectorAll('*').map(function (node) {
          return node.nodeName;
        })

        함수형 프로그래밍은 객체가 아닌 함수를 중심으로 기술되기 때문에 객체에 의존적이지 않아 다형성을 구현하기 수월하다.

        map은 array나 array_like 등 객체의 영향을 받지 않고 보다 실용적으로 실행 가능함
        (이 경우 length 속성이 있는 객체에 한정하여 동작 가능함)
      */
      _map(document.querySelectorAll('*'), function (node) {
        return node.nodeName;
      });

      //       2.2.3. 내부 다형성
      //       2.2.3.1. predi, iter, mapper
      /*
        > 함수형함수, 고차함수, 응용함수같은 경우에는 개발자가 다루는 보조함수에 의해 제어가 결정되기 때문에 데이터 처리에 대해 자유도가 높고 내부 다형성을 유지할 수 있게 된다.
      */

      // 3. 커링
      /* 
        > 함수와 인자를 다루는 기법으로, 인자가 모두 충족되었을 때 평가를 진행한다.
        자바스크립트는 커리를 지원하지 않지만 평가 시점을 제어할 수 있기 때문에 커리를 구현 할 수 있다.
      */
      // 3.1. _curry, _curryr
      // _.js로 이동
      // function _curry(fn) {
      //   return function (a, b) {
      //     return arguments.length == 2
      //       ? fn(a, b)
      //       : function (b) {
      //           return fn(a, b);
      //         };
      //   };
      // }

      var add = _curry(function (a, b) {
        return a + b;
      });

      var add10 = add(10);
      var add5 = add(5);
      console.log(add10(5), add(3)(5), add5(7), add(1, 2));

      // 문맥적 표현력을 위해 인자의 적용 순서가 반대여야 하는 경우가 발생 함

      // _.js로 이동
      // function _curryr(fn) {
      //   return function (a, b) {
      //     return arguments.length == 2
      //       ? fn(a, b)
      //       : function (b) {
      //           return fn(b, a);
      //         };
      //   };
      // }

      var sub = _curryr(function (a, b) {
        return a - b;
      });
      var sub10 = sub(10);

      console.log(sub10(5), sub(3)(5), sub(1, 2));

      // 3.2. _get 만들어 좀 더 간단하게 하기
      // _.js로 이동
      // var _get = _curryr(function (obj, key) {
      //   return obj == null ? undefined : obj[key];
      // });

      // curry를 사용하여 함수의 목적을 보다 명확하게 만들 수 있다
      var getName = _get('name');
      console.log(_get(users[0], 'name'), _get(users[10], 'name'));
      console.log(getName(users[0]), getName(users[10]));

      // > 위 2.1. 문제를 다음과 같이 보다 명확하게 정리 할 수 있다
      console.log(
        _map(
          _filter(users, function (user) {
            return user.age >= 30;
          }),
          _get('name')
        )
      );

      console.log(
        _map(
          _filter(users, function (user) {
            return user.age < 30;
          }),
          _get('age')
        )
      );

      // 4. _reduce 만들기
      function _reduce(list, iter, memo) {
        _each(list, function (val) {
          memo = iter(memo, val);
        });
        return memo;
      }

      console.log(_reduce([1, 2, 3], add, 0));

      // 5. 파이프라인 만들기
      // 5.1. _pipe
      // 5.2. _go
      // 5.3. users에 _go 적용
      // 5.4. 화살표 함수 간단히

      // 6. _each의 외부 다형성 높이기
      // 6.1. _each에 null 넣어도 에러 안나게
      // 6.2. _keys 만들기
      // 6.3. _keys에서도 _is_object인지 검사하여 null 에러 안나게
      // 6.4. _each 외부 다형성 높이기
    </script>
  </body>
</html>
